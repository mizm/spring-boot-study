# spring-boot-study
spring-boot-study

# Solid
1. SRP - 단일 책임 원칙
2. OCP - 개방 폐쇄 원칙
    - 변경에는 닫겨있고 확장에는 열려있다.
    - interface를 통해 역할이 같은 객체로 변경할때는 다른 코드의 변경이 필요없다.
    - 다형성을 사용했지만 ocp원칙을 지킬 수 없기 때문에 di 라는 원칙이 생긴다.
3. LSP - 리스코프치환원칙
    - 상속된(구현된) 자식은 부모를 완전히 대체해야한다.
    - 인터페이스를 구현한 구현체는 인터페이스를 완전히 대체한다.
    - 컴파일에 단순한게 아니고 기능적인 구현을 보장해야함.
    - ex) 자동차 인터페이스의 엑셀은 앞으로 가는 기능인데 뒤로가게 구현하면 위반
4. ISP - 인터페이스 분리 원칙
    - 특정 클라이언틀르 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 자동차 인터페이스 -> 운전, 정비 인터페이스
        - 사용자 클라이언트를 운전사 클라이언트, 정비사 클라이언트로 분리할 수 있음.
    - 분리하면 다른 인터페이스가 변해도 영향을 주지 않는다.
    - 인터페이스가 명확해지고, 대체 가능성이 높아진다.
5. DIP - 의존 관계 역전 원칙
    - 추상화에 의존해야 한다. 구체화는 의존하지 않는다.
    - 구현 클래스에 의존하지말고 인터페이스에 의존해라
    - 결국 역할에 의존해라. 객체지향에서는 역할이 중요하지 그 역할을 누가하는 지는 중요하지 않다.

# Spring
- DI를 통해 OCP, DIP를 가능하게 지원
- 클라이언트 코드의 변경 없이 기능 확장
- 모든 설계에 `역할`과 `구현`을 분리하자
- 이상적으로는 모든 설계에 인터페이스를 부여해야함
    - 구현기술을 바꾸더라도 변화하기가 쉬움
- 실무적으로 고민
    - 추상화 하려면 비용이 들어감
    - 뭔가 문제가 생겼을떄도 인터페이스 -> 구현 클래스를 찾아서 들어가야함


## IOC DI Container
- IOC 제어의 역전
    - 기본적으로 클라이언트의 구현 객체가 스스로 생성하는 제어 하는 구조이다.
    - 하지만, AppConfig를 통해 생성하는 흐름을 다른 객체가 하도록 역전한다.
    - 클라이언트 조차도 AppConfig가 생성한다.
    - 프레임워크 vs 라이브러리
        - 내가 작성한 코드를 다른 곳에서 실행하면 프레임워크 ( 제어의 흐름이 내가 작성한 코드가 아니다.)
        - 라이브러니는 내가 작성하고 내가 사용한다. ( 제어의 흐름이 내가 작성한 코드이다.)
- DI 의존관계 주입
    - 클라이언트는 인터페이스에 의존하고, 실제 어떤 구현 객체가 사용될지는 모른다.
    - 정적인 클래스 의존관계와 런타임에 결정되는 동적인 객체를 분리해야함
    - 정적인 클래스 의존관계
        - 코드상에 나오는 import등을 통해 바로 분석가능한 의존관계 MemberService - Member
    - 동적인 클래스 의존관계
        - 코드 상에서 어떤 의존관계가 생성 될지 알 수 없다.
        - 런타임 시에 외부에서 실제 구현 객체를 클라이언트에 주입하는 것이 의존관계 주입이라고 한다.
        - 의존관계 중비을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 변경한다.
        - OrderSerivceImpl - DiscountPolicy (FixDiscountPolicy, RateDiscountPolicy) 
- IOC 컨테이너, DI 컨테이너
    - AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것
    - 의존관계 주입에 초점을 맞추어 최근에는 `DI 컨테이너`라고 한다.

## ApplicationContext
- `new AnnotationConfigApplicationContext(AppConfig.class)` 를 호출하면 appconfig @bean이라고 등록된 클래스 정보를 통해 빈을 등록한다
- 무조건 빈은 항상 다른 이름으로 부여해야한다
- 객체를 생성하고 빈들끼리의 의존관계를 설정한다.
- 단순히 자바 코드를 호출하는게 아니고 싱글톤 레지스트리를 통해 조금 다르게 동작한다.

## 빈 조회 기본
- `getBean()`

## 빈팩토리와 어플리케이션 컨텍스트
- 빈팩토리 -> 어플리케이션 컨텍스트
- 빈팩토리
    - 스프링 컨테이너 최상위 인터페이스
    - 스프링 빈을 관리하고 조회한다.
    - getBean을 제공
- 어플리케이션 컨텍스트
    - 빈 조회 기능 이외에 수 많은 부가기능이 필요하다.
    - 메시지소스를 활용한 국제화 기능 ( 한국에서 들어오면 한국어로)
    - 환경변수 (local, dev, prod) 구분해서 처리
    - 애플리케이션 이벤트 - 이벤트를 발생하고 구독하는 모델을 편리하게 지원
    - 편리한 리소스 조회 - 파일 클래스패스 외부 등에서 리소스를 편리하게 조회

## BeanDefinition
- 설정 형식을 지원하는 추상화
- xml을 읽어서 BeanDefinition을 만들기
- 자바코드를 읽어서 BeanDefinition을 만들기
- 빈 설정 메타정보이다.
    - @Bean <bean>로 각각 메타정보를 생성한다.
- 스프링 컨테이너는 메타정보를 바탕으로 빈을 생성한다.

- 자바코드 기반은 팩토리 메서드를 통해 빈을 등록함.